<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\main.js - Thrust JS Framework</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="Thrust JS Framework"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/thrust.config.html">thrust.config</a></li>
            
                <li><a href="..&#x2F;classes/thrust.Convention.html">thrust.Convention</a></li>
            
                <li><a href="..&#x2F;classes/thrust.data.html">thrust.data</a></li>
            
                <li><a href="..&#x2F;classes/thrust.data.config.html">thrust.data.config</a></li>
            
                <li><a href="..&#x2F;classes/thrust.data.convention.html">thrust.data.convention</a></li>
            
                <li><a href="..&#x2F;classes/thrust.data.Data.html">thrust.data.Data</a></li>
            
                <li><a href="..&#x2F;classes/thrust.data.DataFacade.html">thrust.data.DataFacade</a></li>
            
                <li><a href="..&#x2F;classes/thrust.data.ResponseQueue.html">thrust.data.ResponseQueue</a></li>
            
                <li><a href="..&#x2F;classes/thrust.dom.config.html">thrust.dom.config</a></li>
            
                <li><a href="..&#x2F;classes/thrust.dom.convention.html">thrust.dom.convention</a></li>
            
                <li><a href="..&#x2F;classes/thrust.Events.html">thrust.Events</a></li>
            
                <li><a href="..&#x2F;classes/thrust.Facade.html">thrust.Facade</a></li>
            
                <li><a href="..&#x2F;classes/thrust.instance.html">thrust.instance</a></li>
            
                <li><a href="..&#x2F;classes/thrust.Log.html">thrust.Log</a></li>
            
                <li><a href="..&#x2F;classes/thrust.mediator.html">thrust.mediator</a></li>
            
                <li><a href="..&#x2F;classes/thrust.mediator.config.html">thrust.mediator.config</a></li>
            
                <li><a href="..&#x2F;classes/thrust.mediator.convention.html">thrust.mediator.convention</a></li>
            
                <li><a href="..&#x2F;classes/thrust.mediator.Mediator.html">thrust.mediator.Mediator</a></li>
            
                <li><a href="..&#x2F;classes/thrust.mediator.MediatorFacade.html">thrust.mediator.MediatorFacade</a></li>
            
                <li><a href="..&#x2F;classes/thrust.Module.html">thrust.Module</a></li>
            
                <li><a href="..&#x2F;classes/thrust.spa.html">thrust.spa</a></li>
            
                <li><a href="..&#x2F;classes/thrust.spa.config.html">thrust.spa.config</a></li>
            
                <li><a href="..&#x2F;classes/thrust.spa.convention.html">thrust.spa.convention</a></li>
            
                <li><a href="..&#x2F;classes/thrust.spa.SinglePageApp.html">thrust.spa.SinglePageApp</a></li>
            
                <li><a href="..&#x2F;classes/thrust.template.html">thrust.template</a></li>
            
                <li><a href="..&#x2F;classes/thrust.template.config.html">thrust.template.config</a></li>
            
                <li><a href="..&#x2F;classes/thrust.template.convention.html">thrust.template.convention</a></li>
            
                <li><a href="..&#x2F;classes/thrust.template.Template.html">thrust.template.Template</a></li>
            
                <li><a href="..&#x2F;classes/thrust.template.TemplateFacade.html">thrust.template.TemplateFacade</a></li>
            
                <li><a href="..&#x2F;classes/thrust.Thrust.html">thrust.Thrust</a></li>
            
                <li><a href="..&#x2F;classes/thrust.util.html">thrust.util</a></li>
            
                <li><a href="..&#x2F;classes/thrust.util.array.html">thrust.util.array</a></li>
            
                <li><a href="..&#x2F;classes/thrust.util.collection.html">thrust.util.collection</a></li>
            
                <li><a href="..&#x2F;classes/thrust.util.func.html">thrust.util.func</a></li>
            
                <li><a href="..&#x2F;classes/thrust.util.obj.html">thrust.util.obj</a></li>
            
                <li><a href="..&#x2F;classes/thrust.util.type.html">thrust.util.type</a></li>
            
                <li><a href="..&#x2F;classes/thrust.util.url.html">thrust.util.url</a></li>
            
                <li><a href="..&#x2F;classes/thrust.util.when.html">thrust.util.when</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/thrust.html">thrust</a></li>
            
                <li><a href="..&#x2F;modules/thrust.config.html">thrust.config</a></li>
            
                <li><a href="..&#x2F;modules/thrust.data.html">thrust.data</a></li>
            
                <li><a href="..&#x2F;modules/thrust.data.config.html">thrust.data.config</a></li>
            
                <li><a href="..&#x2F;modules/thrust.data.convention.html">thrust.data.convention</a></li>
            
                <li><a href="..&#x2F;modules/thrust.dom.html">thrust.dom</a></li>
            
                <li><a href="..&#x2F;modules/thrust.dom.config.html">thrust.dom.config</a></li>
            
                <li><a href="..&#x2F;modules/thrust.dom.convention.html">thrust.dom.convention</a></li>
            
                <li><a href="..&#x2F;modules/thrust.mediator.html">thrust.mediator</a></li>
            
                <li><a href="..&#x2F;modules/thrust.mediator.config.html">thrust.mediator.config</a></li>
            
                <li><a href="..&#x2F;modules/thrust.mediator.convention.html">thrust.mediator.convention</a></li>
            
                <li><a href="..&#x2F;modules/thrust.spa.html">thrust.spa</a></li>
            
                <li><a href="..&#x2F;modules/thrust.spa.config.html">thrust.spa.config</a></li>
            
                <li><a href="..&#x2F;modules/thrust.spa.convention.html">thrust.spa.convention</a></li>
            
                <li><a href="..&#x2F;modules/thrust.template.html">thrust.template</a></li>
            
                <li><a href="..&#x2F;modules/thrust.template.config.html">thrust.template.config</a></li>
            
                <li><a href="..&#x2F;modules/thrust.template.convention.html">thrust.template.convention</a></li>
            
                <li><a href="..&#x2F;modules/thrust.util.html">thrust.util</a></li>
            
                <li><a href="..&#x2F;modules/thrust.util.array.html">thrust.util.array</a></li>
            
                <li><a href="..&#x2F;modules/thrust.util.collection.html">thrust.util.collection</a></li>
            
                <li><a href="..&#x2F;modules/thrust.util.func.html">thrust.util.func</a></li>
            
                <li><a href="..&#x2F;modules/thrust.util.obj.html">thrust.util.obj</a></li>
            
                <li><a href="..&#x2F;modules/thrust.util.type.html">thrust.util.type</a></li>
            
                <li><a href="..&#x2F;modules/thrust.util.url.html">thrust.util.url</a></li>
            
                <li><a href="..&#x2F;modules/thrust.util.when.html">thrust.util.when</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\main.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
define([
    &#x27;require&#x27;, &#x27;thrust&#x2F;log&#x27;, &#x27;thrust&#x2F;util&#x27;, &#x27;thrust&#x2F;config&#x27;, &#x27;.&#x2F;ignite&#x27;, &#x27;thrust&#x2F;module&#x27;, &#x27;domReady&#x27;, &#x27;module&#x27;, &#x27;.&#x2F;instance&#x27;, &#x27;has&#x27;
],
function (require, log, util, tConfig, igniteSpec, Module, domReady, module, thrustInstance, has)
{
    &#x2F;**
        The thrust application!

    @module thrust
    @main thrust
    **&#x2F;
    &#x27;use strict&#x27;;

    var INIT             = &#x27;init&#x27;,
        START            = &#x27;start&#x27;,
        READY            = &#x27;ready&#x27;,
        STOP             = &#x27;stop&#x27;,
        DESTROY          = &#x27;destroy&#x27;,
        COUNTDOWN        = &#x27;countdown&#x27;,
        IGNITE           = &#x27;ignite&#x27;,
        ORBIT            = &#x27;orbit&#x27;,
        DEORBIT          = &#x27;deorbit&#x27;,
        SPLASHDOWN       = &#x27;splashdown&#x27;,
        memoize          = util.memoize,
        each             = util.each,
        map              = util.map,
        when             = util.when,
        bind             = util.bind,
        type             = util.type,
        isArray          = util.isArray,
        slice            = Array.prototype.slice,
        toArray          = util.toArray,
        format           = util.format,
        resolveMethods   = [INIT, START, READY, STOP, DESTROY],
        instances        = thrustInstance.instances,
        loadingInstances = thrustInstance.loadingInstances;

    &#x2F;**
        The primary thrust class.
    
    @class thrust.Thrust
    @constructor
    @param {String} name The name of this thrust instance
    @returns {Thrust}
    **&#x2F;
    var Thrust = function (name)
    {
        this.name = name;
        this.modules = {};
        this.failedModules = {};
        has(&#x27;DEBUG&#x27;) &amp;&amp; log.info(name);
    };

    &#x2F;&#x2F;#region Runner Factories
    var runRunnerFactory, runnerFactory, allRunnerFactory;
    runRunnerFactory = memoize(function (method)
    {
        var conventionMethod = (method === STOP &amp;&amp; START) || (method === DESTROY &amp;&amp; INIT) || method,
            conventionValue = !(method === STOP || method === DESTROY),
            unsetReady = method === STOP,
            conventionCheck = conventionMethod !== method,
            conventionName = format(&#x27;{0}-status&#x27;, conventionMethod),
            runner = runnerFactory(method, conventionName, conventionValue, unsetReady),
            logMessage = format(&#x27;Thrust: {0}ing module &quot;{{0}}&quot; failed!&#x27;, method),
            runningMessage = format(&#x27;Thrust: Running {0} for module &quot;{{0}}&quot;.&#x27;, method);

        return function (names)
        {
            var that = this;
            if (!isArray(names))
                names = [names];
            var args = slice.call(arguments, 1),
                results = [];
            each(names, function (name)
            {
                has(&#x27;DEBUG&#x27;) &amp;&amp; log.debug(format(runningMessage, name));
                var mod = that.modules[name];

                if (!mod &amp;&amp; !that.failedModules[name])
                {
                    &#x2F;&#x2F; try to fetch the module.
                    &#x2F;&#x2F; returning the proper defer in it&#x27;s place
                    var loaderDefer = when.defer();

                    require([name], function (moduleDefn)
                    {
                        that.createModule(moduleDefn.name || name, moduleDefn);

                        var result = runRunnerFactory(method).apply(that, [name].concat(args));
                        when.chain(when.all(util.flatten(result)), loaderDefer);
                    }, function ()
                    {
                        that.failedModules[name] = true;
                        loaderDefer.resolve();
                    });

                    results.push(loaderDefer);
                }
                else if ((conventionCheck &amp;&amp; mod.convention(conventionName)) || !mod.convention(conventionName))
                {
                    if (tConfig.throwErrors)
                    {
                        results.push(runner(that, name, mod, args));
                    }
                    else
                    {
                        try
                        {
                            results.push(runner(that, name, mod, args));
                        }
                        catch (e)
                        {
                            has(&#x27;DEBUG&#x27;) &amp;&amp; log.error(format(logMessage, name), e, e.stack);
                        }
                    }
                }
            });

            return results;
        };
    });

    runnerFactory = memoize(function (method, conventionName, conventionValue, unsetReady)
    {
        var eventName = format(&#x27;thrust&#x2F;module&#x2F;{0}&#x27;, method),
            infoFormat = format(&#x27;Thrust: {0}ing module &quot;{{0}}&quot;&#x27;, method.charAt(0).toUpperCase() + method.substring(1)),
            debugFormat = format(&#x27;Thrust: Calling module &quot;{{0}}&quot; {0}()&#x27;, method),
            compAfter = method === STOP || method === DESTROY || false;

        return function (that, name, mod, args)
        {
            has(&#x27;DEBUG&#x27;) &amp;&amp; log.info(format(infoFormat, name));
            has(&#x27;DEBUG&#x27;) &amp;&amp; log.debug(format(conventionName, name));
            return mod.thrustCall(method, compAfter, args).then(function ()
            {
                that.mediator.fire(eventName, name);
                mod.convention(conventionName, conventionValue);
                if (unsetReady) mod.convention(READY + &#x27;-status&#x27;, false);
            });
        };
    });

    allRunnerFactory = memoize(function (method)
    {
        var infoFormat = format(&#x27;Thrust: {0}ing all modules... [{{0}}]&#x27;, method.charAt(0).toUpperCase() + method.substring(1)),
            pluralName = format(&#x27;thrust&#x2F;module&#x2F;all&#x2F;{0}&#x27;, method),
            checkAutoStart = method === INIT || method === START;

        return function (that)
        {
            that.mediator.fire(pluralName);
            var modules = that.modules,
                results = [];

            has(&#x27;DEBUG&#x27;) &amp;&amp; log.info(format(infoFormat, util.map(modules, function(x, i) { return x.convention(&#x27;autoStart&#x27;) &amp;&amp; i; }).join(&#x27;, &#x27;)));
            each(modules, function (x, i)
            {
                if (!checkAutoStart || (checkAutoStart &amp;&amp; x.convention(&#x27;autoStart&#x27;)))
                    results.push(that[method](i));
            });

            if (that.startingModules &amp;&amp; checkAutoStart)
            {
                has(&#x27;DEBUG&#x27;) &amp;&amp; log.info(format(infoFormat, that.startingModules.join(&#x27;, &#x27;)));
                that[method](that.startingModules);
            }

            return when.all(results);
        };
    });

    var flattenWithAsync = function (that, arr)
    {
        return util.flatten(arr.concat(that.cfg.async &amp;&amp; [when.delay(0)] || []));
    };
    &#x2F;&#x2F;#endregion
    
    Thrust.prototype = Thrust.fn = {
        &#x2F;**
            Required methods, that every module must implement.
    
        @property __requiredMethods
        @protected
        **&#x2F;
        __requiredMethods: [     &#x2F;&#x2F; Required methods that must be on every module
            &#x27;init&#x27;,
            &#x27;destroy&#x27;
        ],
        __conventions: [],
        cfg: { async: false },
        &#x2F;**
            Creates a new thrust module.

        @method create
        @param {String} name The unique module name.
        @param {Object} module The module defintion.
        @param {Boolean} preBuild Has this module been prebuilt, in other words has it been created, by wire.js and needs to be injected.
        @returns {Module} The new module instance.
        **&#x2F;
        create: function (name, module, preBuilt)
        {
            has(&#x27;DEBUG&#x27;) &amp;&amp; log.debug(format(&#x27;Thrust: Creating new instance of &quot;{0}&quot;&#x27;, name));

            var oldModule;
            if (preBuilt)
            {
                oldModule = module;
                module = module.instance;
            }

            if (!preBuilt)
                module = new Module(this, module, name);
            else
                module = oldModule;

            &#x2F;&#x2F; Modules cannot have duplicate names, choose a new one.
            if (this.modules[module.name])
                throw new Error(format(&#x27;Duplicate module name &quot;{0}&quot;.&#x27;, name));

            &#x2F;&#x2F; m is the mediators internal module.
            this.modules[module.name] = module;

            has(&#x27;DEBUG&#x27;) &amp;&amp; log.info(format(&#x27;Thrust: Created module &quot;{0}&quot;&#x27;, name));
            &#x2F;&#x2F; Notify the mediator that a module has been created.
            this.mediator.fire(&#x27;thrust&#x2F;module&#x2F;create&#x27;, name);

            if (this.mediator.started &amp;&amp; module.convention(&#x27;autoStart&#x27;))
                this.mediator.start(module.name);

            return module;
        },
        &#x2F;&#x2F;#region Global Runners
        &#x2F;**
            Begins the countdown to thrusts start.
            Loading can be deferred by returning a promise from any convention, or module method.

        @method countdown
        @async
        @returns {Promise} The promise of when the countdown is completed.
        **&#x2F;
        countdown: function ()
        {
            var that = this;
            has(&#x27;DEBUG&#x27;) &amp;&amp; log.debug(format(&#x27;Launch instance &quot;{0}&quot; in 5... 4... 3... 2... 1...&#x27;, that.name));
            return when.all(flattenWithAsync(that, [
                util.safeInvoke(that.__conventions, COUNTDOWN, that),
                that.init()
            ]))
                .then(function () { that.mediator.fire(&#x27;thrust&#x2F;init&#x27;); })
                .then(function() { has(&#x27;DEBUG&#x27;) &amp;&amp; log.debug(format(&#x27;Thrust instance &quot;{0}&quot; has been initalized.&#x27;, that.name)); })
                .then(bind(that.ignite, that));
        },
        &#x2F;**
            Begins the ingition as thrust starts up.
            Loading can be deferred by returning a promise from any convention, or module method.

        @method ignite
        @async
        @returns {Promise} The promise of when the ingition is completed.
        **&#x2F;
        ignite: function ()
        {
            var that = this;
            has(&#x27;DEBUG&#x27;) &amp;&amp; log.debug(format(&#x27;Firing rockets for thurst instance &quot;{0}&quot;.&#x27;, that.name));
            return when.all(flattenWithAsync(that, [
                util.safeInvoke(that.__conventions, IGNITE, that),
                that.start()
            ]))
                .then(function () { that.mediator.fire(&#x27;thrust&#x2F;start&#x27;); })
                .then(function () { has(&#x27;DEBUG&#x27;) &amp;&amp; log.debug(format(&#x27;Thrust instance &quot;{0}&quot; has been started.&#x27;, that.name)); })
                .then(bind(that.orbit, that));
        },
        &#x2F;**
            Thrust prepares for orbit.
            Loading can be deferred by returning a promise from any convention.

        @method orbit
        @async
        @returns {Promise} The promise of when thrust is in orbit.
        **&#x2F;
        orbit: function ()
        {
            var that = this;
            has(&#x27;DEBUG&#x27;) &amp;&amp; log.debug(format(&#x27;Firing stage two thrusters for thrust instance &quot;{0}&quot;.&#x27;, that.name));
            var domReadyDefer = when.defer();
            domReadyDefer.then(function () { that.mediator.fire(&#x27;thrust&#x2F;dom&#x2F;ready&#x27;); });
            domReady(domReadyDefer.resolve);

            return when.all(flattenWithAsync(that, [
                domReadyDefer.promise,
                util.safeInvoke(that.__conventions, ORBIT, that)
            ])).then(function ()
            {
                if (has(&#x27;DEBUG&#x27;))
                {
                    var timeStart = that.config.debug.timeStart,
                    timeEnd       = new Date().getTime(),
                    startTime     = (timeEnd - timeStart),
                    ttoDiv        = document.getElementById(&#x27;tto&#x27;);

                    if (ttoDiv)
                        ttoDiv.innerHTML = startTime + &#x27;ms&#x27;;
                }

                when.all(flattenWithAsync(that, [that.ready()]))
                    .then(function () { that.mediator.fire(&#x27;thrust&#x2F;ready&#x27;); })
                    .then(function () { has(&#x27;DEBUG&#x27;) &amp;&amp; log.debug(format(&#x27;Thrust instance &quot;{0}&quot; is now ready.&#x27;, that.name)); })
                    .then(bind(that.inOrbit, that));
            });
        },
        inOrbit: function ()
        {
            var that = this;
            that.started = true;

            if (has(&#x27;DEBUG&#x27;))
            {
                var timeStart = that.config.debug.timeStart,
                    timeEnd = new Date().getTime(),
                    startTime = (timeEnd - timeStart);

                log.info(&#x27;Started in &#x27; + startTime + &#x27;ms&#x27;);

                var ttrDiv = document.getElementById(&#x27;ttr&#x27;);
                if (ttrDiv)
                    ttrDiv.innerHTML = startTime + &#x27;ms&#x27;;
            }
        },
        &#x2F;**
            Begins the deorbit as thrust shutdown.
            Shutdown can be deferred by returning a promise from any convention, or module method.

        @method deorbit
        @async
        @returns {Promise} The promise of when the ingition is completed.
        **&#x2F;
        deorbit: function ()
        {
            var that = this;
            has(&#x27;DEBUG&#x27;) &amp;&amp; log.debug(format(&#x27;Reentering earths atmosphere for thrust instance &quot;{0}&quot;.&#x27;, that.name));
            return when.all(flattenWithAsync(that, [
                that.stop(),
                util.safeInvoke(that.__conventions, DEORBIT, that)
            ]))
                .then(function () { that.mediator.fire(&#x27;thrust&#x2F;stop&#x27;); })
                .then(function () { has(&#x27;DEBUG&#x27;) &amp;&amp; log.debug(format(&#x27;Thrust instance &quot;{0}&quot; is now stopped.&#x27;, that.name)); })
                .then(bind(that.orbit, that));
        },
        &#x2F;**
            Begins the splashdown as thrust shutdown.
            Shutdown can be deferred by returning a promise from any convention, or module method.

        @method splashdown
        @async
        @returns {Promise} The promise of when the ingition is completed.
        **&#x2F;
        splashdown: function ()
        {
            var that = this;
            has(&#x27;DEBUG&#x27;) &amp;&amp; log.debug(format(&#x27;Landing in the middle of the atlantic for thrust instance &quot;{0}&quot;.&#x27;, that.name));
            return when.all(flattenWithAsync(that, [
                that.stop(),
                util.safeInvoke(that.__conventions, SPLASHDOWN, that)
            ]))
                .then(function () { that.mediator.fire(&#x27;thrust&#x2F;destroy&#x27;); })
                .then(function () { has(&#x27;DEBUG&#x27;) &amp;&amp; log.debug(format(&#x27;Thrust instance &quot;{0}&quot; is now being destroyed&#x27;, that.name)); });
            &#x2F;&#x2F; do destroy
        },
        &#x2F;&#x2F;#endregion
        &#x2F;&#x2F;#region Module runners
        &#x2F;**
            Begins the initalization process for a module.  This runs as part of the
                countdown phase, during start up, or in order, when creating modules.
            Loading can be deferred by returning a promise from any convention, or module method.

        @method init
        @param {String|Array of String} [name] The name of the module.  If name is null, all modules
            that return the property autoStart will be inited.
        @returns {Promise} The promise of when the init is completed.
        **&#x2F;
        init: memoize(function (name)
        {
            var that = this, method = INIT;

            var result = !name &amp;&amp; allRunnerFactory(method)(that);
            if (result)
                return result;

            var args = arguments;
            if (isArray(name))
                result = map(name, function (x) { return that.init(x); });
            else
                result = runRunnerFactory(method).apply(that, arguments);

            return when.all(util.flatten(result));
        }),
        &#x2F;**
            Begins the startup process for a module.  This runs as part of the
                ignite phase, during start up, or in order, when creating modules.
            Loading can be deferred by returning a promise from any convention, or module method.

        @method start
        @param {String|Array of String} [name] The name of the module.  If name is null, all modules
            that return the property autoStart will be started.
        @returns {Promise} The promise of when the init is completed.
        **&#x2F;
        start: function (name)
        {
            var that = this, method = START;

            var result = !name &amp;&amp; allRunnerFactory(method)(that);
            if (result)
                return result;

            if (!isArray(name))
                name = [name];

            var items = [];
            for (var i = 0, iLen = name.length; i &lt; iLen; i++)
            {
                var n = name[i],
                    mod = that.modules[n];

                if (!mod)
                {
                    items.push(that.init.call(that, [n].concat(slice.call(arguments, 1))));
                }
                else if (!mod.convention(INIT + &#x27;-status&#x27;))
                {
                    items.push(that.init.call(that, [n].concat(slice.call(arguments, 1))));
                }
            }

            var startDefer = when.defer(),
                args = util.toArray(arguments);
            when.all(util.flatten(items)).then(function ()
            {
                var results = [];
                results.push(runRunnerFactory(method).apply(that, args));

                var resultsDefer = when.all(util.flatten(results));
                if (that.started)
                {
                    var runReady = function () { when.chain(that.ready.apply(that, args), startDefer); };
                    resultsDefer.then(runReady);
                }
                else
                {
                    when.chain(resultsDefer, startDefer);
                }
            });

            return startDefer.promise;
        },
        &#x2F;**
            Begins the ready process for a module.  This runs as part of the
                orbit phase, during ready, or in order, when creating modules.
            Loading can be deferred by returning a promise from any convention, or module method.

        @method ready
        @param {String|Array of String} [name] The name of the module.  If name is null, all modules
            that return the property autoStart will be started.
        @returns {Promise} The promise of when the init is completed.
        **&#x2F;
        ready: function (name)
        {
            var that = this, method = READY;

            var result = !name &amp;&amp; allRunnerFactory(method)(that);
            if (result)
                return result;

            if (!isArray(name))
                name = [name];

            var items = [];
            for (var i = 0, iLen = name.length; i &lt; iLen; i++)
            {
                var n = name[i],
                    mod = that.modules[n];
                if (!mod.convention(START + &#x27;-status&#x27;) &amp;&amp; !that.started)
                {
                    items.push(that.start.apply(that, [n].concat(slice.call(arguments, 1))));
                }
            }

            items.push(runRunnerFactory(method).apply(that, arguments));

            return when.all(util.flatten(items));
        },
        &#x2F;**
            Begins the stop process for a module.  This runs as part of the
                deorbit phase, during stop, or in order, when creating modules.
            Loading can be deferred by returning a promise from any convention, or module method.

        @method stop
        @param {String|Array of String} [name] The name of the module.  If name is null, all modules
            will be stopped.
        @returns {Promise} The promise of when the stop is completed.
        **&#x2F;
        stop: function (name)
        {
            var that = this, method = STOP;

            var result = !name &amp;&amp; allRunnerFactory(method)(that);
            if (result)
                return result;

            if (!isArray(name))
                name = [name];

            result = runRunnerFactory(method).apply(that, arguments);
            return when.all(util.flatten(result));
        },
        &#x2F;**
            Begins the destroy process for a module.  This runs as part of the
                slashdown phase, during destroy, or in order, when creating modules.
            Loading can be deferred by returning a promise from any convention, or module method.

        @method destroy
        @param {String|Array of String} [name] The name of the module.  If name is null, all modules
            will be destroyed.
        @returns {Promise} The promise of when the destroy is completed.
        **&#x2F;
        destroy: function (name)
        {
            var that = this, method = DESTROY;

            var result = !name &amp;&amp; allRunnerFactory(method)(that);
            if (result)
                return result;

            if (!isArray(name))
                name = [name];

            var items = [];
            for (var i = 0, iLen = name.length; i &lt; iLen; i++)
            {
                var n = name[i],
                    mod = that.modules[n];

                if (!mod.convention(STOP + &#x27;-status&#x27;))
                {
                    items.push(that.stop.call(that, [n].concat(slice.call(arguments, 1))));
                }
            }

            items.push(runRunnerFactory(method).apply(that, arguments));
            return when.all(util.flatten(items));
        },
        &#x2F;&#x2F;#endregion
        &#x2F;**
            Injects a preconstructed module into the thrust instance.

        @method __injectModule
        @private
        @param {Module} module The module to inject.
        **&#x2F;
        __injectModule: function (module)
        {
            this.create(module.name, module, true);
        },
        &#x2F;**
        Creates a module from the given definition object, with the given name.

        @method createModule
        @param {String} name The module name
        @param {Object} moduleDefn The module definition
        **&#x2F;
        createModule: function (name, moduleDefn)
        {
            var that = this;
            if (that.modules[name]) return that.modules[name];

            var module = new Module(that, moduleDefn, name);

            that.__injectModule(module);

            return module;
        }
    };

    &#x2F;**
        Initalizes a new Thrust instance based on the given settings.

    @method launch
    @static
    @param {Object} settings The module to inject
    **&#x2F;
    Thrust.launch = function (settings)
    {
        if (!settings)
            settings = { name: &#x27;global&#x27; };

        if (!settings.name)
            settings.name = &#x27;global&#x27;;

        if (has(&#x27;DEBUG&#x27;))
        {
            settings.debug = { timeStart: new Date().getTime() };
        }

        var setupDefer = Thrust.__fetchInstance(settings.name);

        setupDefer.then(function (context)
        {
            var thrust = context.thrust;
            thrust.startingModules = context.cfg.modules;
            thrust.config = thrust.cfg;
            instances[thrust.name] = thrust;
            thrust.countdown();

            return context;
        })
        .then(function (context)
        {
            window.thrust = context.thrust;
        });

        when.chain(igniteSpec.stageOne(settings), setupDefer);

        return setupDefer.promise;
    };

    &#x2F;**
    Gets a named thrust stance if it exists.

    @method getInstance
    @static
    @param {String} name The instance name
    @returns {Thrust} The thrust instance
    **&#x2F;
    Thrust.getInstance = function (name)
    {
        return thrustInstance.getInstance(name);
    };

    &#x2F;**
    Fetchs a named thrust stance if it exists.
    This loads asyncronously, as the instance may not be loaded

    @method __fetchInstance
    @static
    @private
    @param {String} name The instance name
    @returns {Promise} To a thrust instance spec
    **&#x2F;
    Thrust.__fetchInstance = function (name)
    {
        return thrustInstance.fetchInstance(name);
    };

    &#x2F;**
    Creates a new module and hands it off to the given instance, if that instance exists.

    @method createModule
    @static
    @param {String} instanceName The thrust instance name
    @param {String} name The module name
    @param {Object} moduleDefn The module definition
    **&#x2F;
    Thrust.createModule = function (instanceName, name, moduleDefn)
    {
        var instance = Thrust.getInstance(instanceName);
        if (instance)
        {
            var module = new Module(instance, moduleDefn, name);
            instance.__injectModule(module);
            return module;
        }
    };

    &#x2F;**
    AMD API
    load

    Handles fetching of a current thurst instance, by expected name.
    Adding the : character requests a specific plugin.
    thrust!global = Thrust instance
    thrust!global:dom = The thrust dom plugin instance

    @method load
    @static
    @param {String} name The name of the instance that is being fetched
    @param {Function} parentRequire the require method to be loaded
    @param {Function} load Allows the load to inform that AMD for the value to hand off
    @param {Object} config The custom configuration.
    **&#x2F;
    Thrust.load = function (name, parentRequire, load, config)
    {
        var parts = name.split(&#x27;:&#x27;),
            realName = parts[0],
            pluginName = parts[1] || &#x27;thrust&#x27;;

        var instancePromise = Thrust.__fetchInstance(realName);
        instancePromise.then(function (context)
        {
            var plugin = context[pluginName];
            if (!plugin)
                throw new Error(format(&#x27;Plugin &quot;{0}&quot; does not exist on thrust instance &quot;{1}&quot;.&#x27;, pluginName, realName));

            load(plugin);
        });
    };

    return Thrust;
});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
